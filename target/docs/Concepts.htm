<!DOCTYPE HTML>
<html lang="pt-BR">
<head>
<title>Conceitos e Convenções | AutoHotkey</title>
<meta name="description" content="Saiba detalhes sobre conceitos gerais e convenções usadas pelo AutoHotkey, num artigo focado mais na explicação do que no código." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>
<h1>Conceitos e Convenções</h1>
<p>Este documento cobre alguns conceitos gerais e convenções usadas pelo AutoHotkey, num artigo focado mais na explicação do que no código. Não se assume que o leitor tenha qualquer conhecimento prévio de confecção de scripts ou programação, mas deve estar preparado para aprender novas terminologias.</p>
<p>Para detalhes mais específicos sobre a sintaxe, veja <a href="Language.htm">Linguagem de Confecção de Scripts</a>.</p>

<h2 id="toc">Sumário</h2>
<ul>
  <li><a href="#values">Valores</a>
  <ul>
    <li><a href="#strings">Strings</a></li>
    <li><a href="#numbers">Números</a></li>
    <li><a href="#boolean">Valores Booleanos</a></li>
    <li><a href="#nothing">“Nada”</a></li>
    <li><a href="#objects">Objetos</a></li>
    <li><a href="#object-protocol">Protocolo dos Objetos</a></li>
  </ul></li>
  <li><a href="#variables">Variáveis</a>
  <ul>
    <li><a href="#uninitialised-variables">Variáveis Não Inicializadas</a></li>
    <li><a href="#built-in-variables">Variáveis Nativas</a></li>
    <li><a href="#environment-variables">Variáveis de Ambiente</a></li>
    <li><a href="#caching">Caching</a></li>
  </ul></li>
  <li><a href="#functions">Funções/Comandos</a></li>
  <li><a href="#control-flow">Fluxo de Controle</a></li>
  <li><a href="#details">Detalhes</a>
  <ul>
    <li><a href="#string-encoding">Codificação de Strings</a></li>
    <li><a href="#pure-numbers">Números Puros</a></li>
    <li><a href="#names">Nomes</a></li>
    <li><a href="#variable-references">Referências a Variáveis x Valores</a></li>
    <li><a href="#references-to-objects">Referências a Objetos</a></li>
  </ul></li>
</ul><!-- TODO:
Scope/declarations
Technical terms: dynamic, default
Classes
Exception handling
-->


<h2 id="values">Valores</h2>
<p>Um <em>valor</em> é simplesmente um pedaço de informação dentro de um programa. Por exemplo, o nome de uma tecla a ser enviada ou um programa a executar, o número de vezes que uma hotkey foi pressionada, o título de uma janela a ser ativada, ou qualquer que seja a coisa que tenha algum significado dentro do programa ou script.</p>
<p>O AutoHotkey suporta estes tipos de valores:</p>
<ul>
  <li><a href="#strings">Strings</a> (texto)</li>
  <li><a href="#numbers">Números</a> (inteiros e números de ponto flutuante)</li>
  <li><a href="#objects">Objetos</a></li>
</ul>
<p>Alguns outros conceitos relacionados:</p>
<ul>
  <li><a href="#boolean">Valores Booleanos</a></li>
  <li><a href="#nothing">“Nada”</a></li>
</ul>

<h3 id="strings">Strings</h3>
<p>Uma <em>string</em> é simplesmente texto. Cada string é na verdade uma sequência ou <em>cadeia</em> de caracteres, mas pode ser tratada como uma entidade única. O <em>comprimento</em> de uma string é o número de caracteres na sequência, enquanto a <em>posição</em> de um caractere na string é meramente o número sequencial daquele caractere. No AutoHotkey, por convenção, o primeiro caractere está na posição 1.</p>
<p id="numeric-strings"><strong>Strings numéricas</strong>: uma string de dígitos (ou qualquer outro <a href="#numbers">formato de número</a> suportado) é automaticamente interpretado como um número quando uma operação matemática ou comparação o requer. Na versão 1 do AutoHotkey, comparações são feitas numericamente se ambos os valores são números mesmo que ambos sejam strings. Entretanto, uma string entre aspas (ou o resultado de da concatenação com uma string entre aspas) nunca é considerada numérica quando usada diretamente numa expressão.</p>
<p>A forma com que texto literal deve ser escrito dentro do script depende do contexto. Para detalhes, veja <a href="Language.htm#legacy-syntax">Sintaxe Legada</a> e <a href="Language.htm#strings">Strings (em expressões)</a>.</p>
<p>Para uma explicação mais detalhada de como strings funcionam, veja <a href="#string-encoding">Codificação de Strings</a>.</p>

<h3 id="numbers">Números</h3>
<p>O AutoHotkey suporta estes formatos de números:</p>
<ul>
  <li>Inteiros decimais, como <code>123</code>, <code>00123</code> ou <code>-1</code>.</li>
  <li>Inteiros hexadecimais, como <code>0x78</code>, <code>0x007B</code> ou <code>-0x1</code>.</li>
  <li>Números decimais de ponto flutuante, como <code>3.14159</code>.</li>
</ul>
<p>Números hexadecimais devem usar o prefixo <code>0x</code> ou <code>0X</code>, exceto onde estiver especificado na documentação. Esse prefixo deve ser escrito depois do sinal de <code>+</code> ou <code>-</code>, se presente, e antes de quaisquer zeros à esquerda. Por exemplo, <code>0x001</code> é válido, mas <code>000x1</code> não é.</p>
<p>Números escritos com uma casa decimal são sempre considerados como ponto flutuante, mesmo quando a parte fracionária é zero. Por exemplo, <code>42</code> e <code>42.0</code> são geralmente equivalentes, mas nem sempre. Notação científica também é reconhecida, mas somente se uma casa decimal estiver presente (exemplo: <code>1.0e4</code> e <code>-2.1E-4</code>).</p>
<p>O separador de casas decimais é sempre um ponto, mesmo se as configurações regionais do usuário especificarem a vírgula.</p>
<p>Quando um número é convertido em uma string, ele é formatado de acordo com o <a href="commands/SetFormat.htm#remarks">formato de inteiro ou decimal</a> atual. Apesar de o comando <a href="commands/SetFormat.htm">SetFormat</a> poder ser usado para alterar o formato atual, costuma ser melhor usar a função <a href="commands/Format.htm">Format</a> para formatar uma string. Números de ponto flutuante também podem ser formatados usando-se a função <a href="commands/Math.htm#Round">Round</a>.</p>
<p>Para detalhes sobre o intervalo e a precisão de valores numéricos, veja <a href="#pure-numbers">Números Puros</a>.</p>

<h3 id="boolean">Valores Booleanos</h3>
<p>Um valor <em>booleano</em> pode ou ser <em>verdadeiro</em> ou <em>falso</em>. Valores booleanos são usados para representar qualquer coisa que tenha  exatamente dois estados possíveis, como a <em>verdade</em> de uma expressão. Por exemplo, a expressão <code>(x &lt;= y)</code> é <em>verdadeira</em> quando x tem valor igual ou menor que y. Um valor booleano também pode representar <em>sim</em> ou <em>não</em>, <em>ligado</em> ou <em>desligado</em>, <em>pressionada</em> ou <em>solta</em> (nas situações em que o estado de uma tecla é verificado, tal como ocorre quando se usa o comando <a href="commands/GetKeyState.htm#function">GetKeyState</a>), entre outros.</p>
<p>O AutoHotkey não tem um tipo específico de valor booleano, então ele usa o valor inteiro <code>0</code> para representar falso e <code>1</code> para representar verdadeiro. Quando se exige que um valor seja verdadeiro ou falso, um valor em branco ou igual a zero é considerado falso e todos os demais valores são considerados verdadeiros. (Objetos sempre são considerados verdadeiros.)</p>
<p>As palavras <code>true</code> e <code>false</code> são <a href="#built-in-variables">variáveis nativas</a> contendo 1 e 0. Elas podem ser usadas para tornar um script mais legível.</p>

<h3 id="nothing">“Nada”</h3>
<p>O AutoHotkey não possui um valor próprio para representar <em>nothing</em>, <em>null</em>, <em>nil</em> ou <em>undefined</em>, como visto em outras linguagens. Em vez disso, uma string vazia (uma string com comprimento zero) é o que costuma fazer esse papel no AHK.</p>
<p>Se uma <a href="#variables">variável</a> ou parâmetro é dito “vazio” ou “em branco”, isso geralmente é o mesmo que uma string vazia (uma string de comprimento zero).</p>

<h3 id="objects">Objetos</h3>
<p>Há normalmente duas maneiras de visualizar objetos:</p>
<ul>
  <li>Um objeto contém um grupo de valores, permitindo que o grupo em si seja tratado como um valor. Por exemplo, um objeto poderia conter um <em>vetor</em> ou sequência de itens, ou um conjunto de valores relacionados, como as coordenadas X e Y de uma posição na tela. Objetos podem ser usados para montar estruturas complexas combinando-se-os com outros objetos.</li>
  <li>Um objeto pode representar uma <em>coisa</em>, um <em>serviço</em>, ou alguma outra coisa, e pode proporcionar maneiras de o script interagir com essa coisa ou serviço. Por exemplo, um objeto <em>ContaBancaria</em> pode ter propriedades como o número da conta, o saldo atual e o titular da conta, e métodos para sacar ou depositar um valor.</li>
</ul>
<p>O uso correto de objetos (e, em particular, <a href="Objects.htm#Custom_Classes">classes</a>) pode resultar em código <em>modular</em> e <em>reusável</em>. Código modular é geralmente mais fácil de testar, entender e manter. Por exemplo, alguém pode melhorar ou modificar uma seção de código sem precisar saber os detalhes de outra seção, e sem ter que realizar as modificações necessárias a tais seções. Código reusável poupa tempo, dispensando a necessidade de escrever e testar código para a mesma tarefa ou tarefas similares a cada vez.</p>
<p>Quando você atribui um objeto a uma <a href="#variables">variável</a>, como no exemplo <code>meuObjeto := {}</code>, o que você armazena não é o objeto em si, mas uma <a href="#references-to-objects"><em>referência</em></a> a ele. Copiar aquela variável, como em <code>seuObjeto := meuObjeto</code>, cria uma nova referência ao <em>mesmo</em> objeto. Uma alteração como <code>meuObjeto.resposta := 42</code> seria refletida tanto em <code>meuObjeto.resposta</code> e <code>seuObjeto.resposta</code>, uma vez que ambos se referem ao mesmo objeto. Contudo, <code>meuObjeto := Object()</code> só afetará a variável <em>meuObjeto</em>, não a variável <em>seuObjeto</em>, a qual ainda se refere ao objeto original.</p>

<h3 id="object-protocol">Protocolo dos Objetos</h3>
<p class="note">Esta seção se baseia nos conceitos seguintes, que são cobertos em seções posteriores: <a href="#variables">variáveis</a>, <a href="#functions">funções</a></p>
<p>Objetos funcionam de acordo com o princípio da <em>troca de mensagens</em>. Você não sabe onde um código ou variáveis de um objeto efetivamente ficam, então você deve passar uma mensagem ao objeto, como “dê-me <em>foo</em>” ou “vá fazer <em>bar</em>”, e esperar que o objeto responda a essa mensagem. Objetos no AutoHotkey suportam as mensagens básicas a seguir:</p>
<ul>
  <li><strong>Get</strong> (obter) um valor.</li>
  <li><strong>Set</strong> (definir) um valor, denotado por <code>:=</code>.</li>
  <li><strong>Call</strong> (chamar) um método, denotado por <code>()</code>.</li>
</ul>
<p>Cada mensagem pode opcionalmente possuir um ou mais <a href="#parameters">parâmetros</a>, (e, para o caso de <strong>Set</strong>, o valor). Normalmente existe pelo menos um parâmetro, e ele é interpretado como o nome de uma propriedade ou método, uma chave ou índice de vetor, dependendo do objeto e como você está usando-o. Os parâmetros de uma mensagem são especificados usando-se três diferentes padrões: <code>.Name</code>, <code>[Parâmetros]</code> e <code>(Parâmetros)</code>, onde <em>Name</em> é um <a href="#names">nome ou identificador</a> literal, e <em>Parâmetros</em> é uma lista de parâmetros (na forma de sub-expressões), a qual pode ser vazia/em branco (<code>[]</code> ou <code>()</code>).</p>
<p>Para <strong>Get</strong> e <strong>Set</strong>, <code>.Name</code> e <code>[Parâmetros]</code> podem ser usados indistintamente, ou em conjunto:</p>
<pre>meuObjeto[arg1, arg2, ..., argN]
meuObjeto.name
meuObjeto.name[arg2, ..., argN]
</pre>
<p>Para <strong>Call</strong>, <code>.Name</code> e <code>[Parâmetro]</code> podem ser usados indistintamente, e devem sempre ser seguidos de <code>(Parâmetros)</code>:</p>
<pre>meuObjeto.name(arg2, ..., argN)
meuObjeto[arg1](arg2, ..., argN)
</pre>
<p>Note que se <code>name</code> estiver presente, ele se torna o primeiro parâmetro. <code>meuObjeto.name</code> é equivalente a <code>meuObjeto["name"]</code>, enquanto <code>meuObjeto.123</code> é equivalente a <code>meuObjeto[123]</code>. Isso é verdade para todo tipo de objeto, então é sempre possível computar o nome de uma propriedade ou método em tempo de execução, em vez de codificá-lo no script.</p>
<p>Apesar de <em>name</em> ou <em>arg1</em> serem considerados como o primeiro parâmetro, lembre-se que esses são somente <em>mensagens</em>, e o objeto está livre para manipulá-los de qualquer maneira. mas não sempNuma chamada de método como as mostradas acima, normalmente o objeto usa <em>name</em> ou <em>arg1</em> para identificar qual método deve ser chamado, e então <em>arg2</em> e seguintes são passados ao método. Com efeito, <em>arg2</em> torna-se o primeiro parâmetro aparente do método.</p>
<p>Geralmente, <strong>Set</strong> tem o mesmo significado de uma atribuição de valor, então usa o mesmo operador:</p>
<pre>meuObjeto[arg1, arg2, ..., argN] := valor
meuObjeto.name := valor
meuObjeto.name[arg2, ..., argN] := valor
</pre>
<p>Também existe uma sintaxe “híbrida” permitida para a instrução <strong>Set</strong>, mas é melhor não a usar:</p>
<pre>meuObjeto.name(arg2, ..., argN) := valor
</pre>
<p>Tecnicamente, o <code>valor</code> é passado como último parâmetro da mensagem <em>Set</em>, entretanto, esse detalhe quase nunca é relevante para autores de scripts. Geralmente alguém pode simplesmente pensar nele como “o valor que está sendo atribuído”.</p>

<h2 id="variables">Variáveis</h2>
<p>Uma variável permite que você use um nome como um marcador de posição de um valor. Já qual valor é esse é algo que pode mudar repetidamente durante o tempo em que seu script estiver rodando. Por exemplo, uma hotkey pode usar uma variável <code>contagem_pressionamentos</code> para contar o número de vezes que ela foi pressionada, e enviar o pressionamento de uma tecla diferente toda vez que <code>contagem_pressionamentos</code> for um múltiplo de 3 (a cada três pressionamentos). Mesmo uma variável à qual somente uma vez é atribuído um valor pode ser útil. Por exemplo, uma variável <code>TituloDoNavegadorWeb</code> pode ser usada para fazer seu código mais fácil de atualizar quando você resolver mudar seu browser preferido, ou se o <a href="misc/WinTitle.htm">título</a> ou <a href="misc/WinTitle.htm#ahk_class">classe de janela</a> muda devido a uma atualização de software.</p>
<p>No AutoHotkey, as variáveis são criadas no momento em que são simplesmente usadas. Cada variável <em>não é</em> permanentemente restrita a um <a href="#values">tipo de dados</a>, mas pode ter um valor de qualquer tipo: string, número ou objeto. Cada variável começa vazia/em branco; em outras palavras, cada variável nova contém uma string vazia até que a ela seja atribuído um outro valor.</p>
<p>Uma variável tem três aspectos principais:</p>
<ul>
  <li>Seu <em>nome</em>.</li>
  <li>A variável em si.</li>
  <li>O <em>valor</em> da variável.</li>
</ul>
<p>Algumas restrições se aplicam a nomes - vide <a href="#names">Nomes</a> para detalhes. Em resumo, é melhor manter nomes que consistam somente em letras ASCII (as quais não diferenciam maiúsculas e minúsculas), algarismos e underscores, e evitar usar nomes que comecem com um algarismo.</p>
<p>Uma variável tem um <strong><em>escopo</em></strong>, o qual define onde no código aquele nome pode ser usado para se referir àquela variável em particular; em outras palavras, onde a variável está <em>visível</em>. Se uma variável não está visível dentro de determinado escopo, o mesmo nome pode ser referir a uma outra variável. Ambas as variáveis podem existir ao mesmo tempo, mas somente uma estará visível a cada parte do script. <a href="Functions.htm#Global">Variáveis globais</a> são visíveis no “escopo global” (isto é, fora de funções), mas devem normalmente ser <a href="Functions.htm#Global">declaradas</a> para ficarem visíveis dentro de uma função. <a href="Functions.htm#Local">Variáveis locais</a> são visíveis somente dentro da função que as criou.</p>
<p>Uma variável pode ser entendida como um contêiner ou local de armazenamento para um valor, então você muitas vezes vai ver que a documentação se refere ao valor da variável como <em>o conteúdo da variável</em>. Para uma variável <code>x := 42</code>, nós também podemos dizer que a variável x tem o número 42 como seu valor, ou que o valor de x é 42.</p>
<p>É importante notar que a variável e seu valor não são a mesma coisa. Exemplificativamente, nós poderíamos dizer “<code>meuVetor</code> é um vetor”, mas o que realmente queremos dizer é que meuVetor é uma variável contendo uma referência a um vetor. O que estamos fazendo é tomar um atalho ao usar o nome da variável para se referir ao seu valor, mas “meuVetor” é na verdade apenas o nome da variável; o objeto vetor não sabe que ele tem um nome, e poderia ser referenciado por várias variáveis diferentes (portanto, vários diferentes nomes).</p>

<h3 id="uninitialised-variables">Variáveis Não Inicializadas</h3>
<p><em>Inicializar</em> uma variável é atribuir a ela um valor inicial. Apesar de o programa automaticamente inicializar todas as variáveis (uma string vazia sendo o valor padrão), é uma boa prática que o script sempre inicialize as variáveis antes do uso. Dessa forma, qualquer pessoa lendo o script pode ver quais variáveis o script usará e quais valores iniciais espera-se que elas tenham.</p>
<p>Costuma ser necessário que o script inicialize qualquer variável cujo valor que se espera que ela armazene seja um número. Por exemplo, <code>x := x + 1</code> não irá funcionar se à variável x nunca tiver sido atribuído um valor antes, já que a <em>string vazia</em> é considerada não numérica. O script deveria ter atribuído um valor inicial, como <code>x := 0</code>. Há alguns casos em que valores vazios <em>são</em> considerados iguais a 0, mas é melhor não pressupor isso.</p>
<p>Autores de scripts podem usar a diretiva <a href="commands/_Warn.htm">#Warn</a> para ajudar a encontrar instâncias em que uma variável é usada sem ter sido inicializada pelo script.</p>

<h3 id="built-in-variables">Variáveis Nativas</h3>
<p>Há várias variáveis úteis que são nativas ao programa e que podem ser referenciadas por qualquer script. Com a exceção de <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a> e <a href="Scripts.htm#cmd">parâmetros da linha de comando</a>, essas variáveis são somente leitura; isto é, seus conteúdos não podem ser diretamente alterados por um script. Por convenção, a maioria dessas variáveis inicia com o prefixo <code>A_</code>, então é melhor evitar usar esse prefixo nas variáveis que você criar.</p>
<p>Algumas variáveis como <a href="Variables.htm#KeyDelay">A_KeyDelay</a> e <a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a> representam configurações que controlam o comportamento do script, e retêm valores separados para cada <a href="misc/Threads.htm">fio de execução</a>. Isso permite que sub-rotinas sejam executadas por novos fios de execução (como hotkeys, menus, timers e afins) para alterar configurações sem afetar outros fios de execução.</p>
<p>Há também algumas variáveis especiais que não são atualizadas periodicamente; em vez disso, seus valores são obtidos ou calculados toda vez que o script referencia essa variável. Por exemplo, <a href="misc/Clipboard.htm">Clipboard</a> obtém o valor do conteúdo atual da área de transferência como texto, e <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a> calcula o número de milissegundos que se passaram desde que a hotkey foi pressionada.</p>
<p>Assuntos relacionados: <a href="Variables.htm#BuiltIn">lista de variáveis nativas</a>.</p>

<h3 id="environment-variables">Variáveis de Ambiente</h3>
<p>Variáveis de ambiente são mantidas pelo sistema operacional. Você pode ver uma lista delas no prompt de comando digitando SET e depois Enter.</p>
<p>Um script pode criar uma variável de ambiente ou alterar o conteúdo de uma com <a href="commands/EnvSet.htm">EnvSet</a>. Tais adições e alterações não são vistas pelo resto do sistema. Todavia, quaisquer programas ou scripts que o script vier a executar por meio do comando <a href="commands/Run.htm">Run</a> ou <a href="commands/Run.htm">RunWait</a> normalmente herdam uma cópia das variáveis de ambiente do script pai.</p>
<p>Recomenda-se que todos os novos scripts obtenham as variáveis de ambiente, como Path, via <a href="commands/EnvGet.htm">EnvGet</a>.</p>
<pre>EnvGet, OutputVar, Path  <em>; Para explicações, veja #NoEnv.</em></pre>
<p>Se um script não possui a diretiva <a href="commands/_NoEnv.htm">#NoEnv</a>, ler uma variável vazia vai, em vez disso, retornar o valor da variável de ambiente com aquele nome, se houver uma. Isso pode causar confusão, então recomenda-se que todos os novos scripts usem #NoEnv.</p>

<h3 id="caching">Caching</h3>
<p>Apesar de que tipicamente imagina-se uma variável armazenando um único valor, e também cada variável seja de um tipo distinto (string, número e objeto), o AutoHotkey automaticamente converte entre números e strings em casos como <code>minhaString + 1</code> e <code>MsgBox %meuNumero%</code>. Já que essas conversões podem ocorrer muito frequentemente, toda vez que uma variável é convertida, o resultado é <em>armazenado no cache</em> da variável.</p>
<p>Como efeito, a variável pode obter tanto uma string quanto um número simultaneamente. Normalmente isso apenas melhora o desempenho do script sem reveses, mas se uma variável contiver tanto um número quanto uma string, então ela é um número, ou é uma string? Essa ambiguidade causa comportamentos inesperados em pelo menos dois casos:</p>
<ol>
  <li>Objetos COM. Para passar parâmetros para um objeto COM, o programa deve converter o conteúdo da variável para ou uma número <em>ou</em> uma string. Alguns objetos COM lançam uma exceção se o tipo errado de valor for passado. Se uma variável possui ambos, o número é usado. Normalmente isso leva ao resultado correto, mas nem sempre.</li>
  <li>Objetos não têm a capacidade de armazenar um número e uma string ao mesmo tempo como uma chave ou valor. Dado que números são mais eficientes no consumo de memória, se uma variável possui ambos, o número é usado (exceto valores de ponto flutuante usados como chaves).</li>
</ol>
<p>O modo lento do <a href="commands/SetFormat.htm">SetFormat</a> força a atribuição de um número puro para imediatamente converter aquele número em uma string. Para inteiros, o número também é armazenado, então isso não tem efeitos adversos para além da performance. Para pontos flutuantes, o número não é armazenado, já que o comando SetFormat afeta a precisão do valor, possivelmente truncando todas as casas decimais. Em outras palavras, o modo lento do SetFormat impede que pontos flutuantes puros sejam armazenados em variáveis.</p>
<p>Tomar o endereço de uma variável efetivamente converte o valor da variável em uma string, desabilitando o cache até que o endereço da variável mude (isso acontece quando sua capacidade muda). Isso é tanto para retrocompatibilidade e também porque o script poderia mudar o valor indiretamente por meio do endereço da variável a qualquer momento, tornando o cache impreciso.</p>

<h3 id="Related">Tópicos relacionados</h3>
<ul>
  <li><a href="Variables.htm#Intro">Variáveis</a>: noções básicas de uso e exemplos.</li>
  <li><a href="Variables.htm#cap">Capacidade de uma Variável e Memória Usada</a>: detalhes sobre limitações.</li>
</ul>

<h2 id="functions">Funções/Comandos</h2>
<p>Uma <em>função</em> ou <em>comando</em> é o meio primordial pelo qual um script <em>faz algo</em>.</p>
<p>Essencialmente, funções e comandos são a mesma coisa, então os conceitos aqui se aplicam a ambos. Entretanto, a longa história do AutoHotkey v1 e a ênfase em retrocompatibilidade têm resultado em uma divisão entre <em>comandos</em>, os quais requerem sintaxe legada, e <em>funções</em>, que requerem a sintaxe de expressão.</p>
<p>Comandos e funções podem ter propósitos diferentes. Algumas funções fazem não mais que realizar um simples cálculo, enquanto outras têm efeitos imediatamente visíveis, como mover uma janela. Uma das vantagens do AutoHotkey é a facilidade com que os scripts podem automatizar outros programas e realizar várias outras tarefas comuns simplesmente chamando algumas funções. Veja a <a href="commands/index.htm">lista de comandos e funções</a> para exemplos.</p>
<p>Ao longo desta documentação, algumas palavras comuns são usadas de maneiras que podem não ser óbvias para alguém sem experiência prévia. Abaixo há várias palavras/expressões que são usadas frequentemente em relação a funções e comandos:</p>
<dl>
  <dt id="call">Chamar uma função ou comando</dt>
  <dd><p><em>Chamar</em> uma função ou comando faz com que o programa invoque, execute ou calcule-o(a). Em outras palavras, uma <em>chamada de função</em> transfere temporariamente o controle do script para a função. Quando a função completar seu propósito, ela <em>retorna</em> o controle ao script. Ou seja, qualquer código que vier depois da chamada de função não executará até que a função complete.</p>
  <p>Contudo, algumas vezes a função ou comando completa antes que seus efeitos possam ser vistos pelo usuário. Por exemplo, o comando <a href="commands/Send.htm">Send</a> <em>envia</em> pressionamentos de teclas, mas podem retornar antes que as teclas pressionadas cheguem ao seu destino e gerem seu efeito pretendido.</p></dd>
  <dt id="parameters">Parâmetros</dt>
  <dd><p>Geralmente um comando ou função aceita <em>parâmetros</em> que podem dizer ao comando ou função como operar ou em que operar. Cada parâmetro é um <a href="#values">valor</a>, como uma string ou um número. Por exemplo, <a href="commands/WinMove.htm">WinMove</a> move uma janela, então seus parâmetros irão dizer qual janela mover e para onde movê-la. Parâmetros também podem ser chamados de <em>argumentos</em>. Abreviaturas comuns são <em>param</em> e <em>arg</em>.</p></dd>
  <dt id="pass-parameters">Passagem de parâmetros</dt>
  <dd><p>Parâmetros são <em>passados</em> para uma função ou comando, o que significa que um valor é especificado para cada parâmetro da função ou comando quando ele(a) é chamado. Por exemplo, alguém pode <em>passar</em> o nome de uma tecla para <a href="commands/GetKeyState.htm#function">GetKeyState()</a> para determinar se aquela tecla está sendo mantida pressionada.</p></dd>
  <dt id="return-a-value">Retornar um valor</dt>
  <dd><p>Funções <em>retornam</em> um valor, então o resultado da função é frequentemente chamado de <em>valor de retorno</em>. Por exemplo, <a href="commands/StrLen.htm">StrLen()</a> retorna o número de caracteres em uma string. Comandos não retornam um valor diretamente; em vez disso, eles armazenam o resultado em uma <a href="#variables">variável</a>. Funções também podem fazer isso, como quando há mais de um resultado.</p></dd>
</dl>
<p>Funções e comandos normalmente aguardam que parâmetros sejam escritos em uma ordem específica, então o significado de cada parâmetro depende de sua posição na lista de parâmetros, que é separada por vírgulas. Alguns parâmetros podem ser omitidos, caso em que o parâmetro deve ser deixado em branco, mas a vírgula seguinte só pode ser omitida se todos os parâmetros que vierem depois também forem omitidos. Por exemplo, a sintaxe para <a href="commands/ControlSend.htm">ControlSend</a> é:</p>
<pre class="Syntax"><span class="func">ControlSend</span> <span class="optional">, Controle, Teclas, TituloDaJanela, TextoDaJanela, ExcluirTitulo, ExcluirTexto</span></pre>
<p>A presença de colchetes nos parâmetros significa que eles são parâmetros opcionais (os colchetes em si não devem aparecer no código). No entanto, ControlSend não tem utilidade a não ser que <em>Teclas</em> sejam especificadas, e geralmente também é necessário especificar a janela alvo. Por exemplo:</p>
<pre>ControlSend, Edit1, ^{Home}, A  <em>; Correto. O controle foi especificado.</em>
ControlSend, ^{Home}, A         <em>; Incorreto: os parâmetros não combinam.</em>
ControlSend,, ^{Home}, A        <em>; Correto. O controle foi omitido.</em>
</pre>

<h3 id="methods">Métodos</h3>
<p><em>Métodos</em> são funções que operam em um <a href="#objects">objeto</a> em particular. Embora só possa existir uma função denominada <code>Send</code> (por exemplo), pode haver tantos métodos denominados <code>Send</code> quanto for o número de objetos, já que cada objeto (ou classe de objetos) pode responder de uma maneira diferente. Por essa razão, o objeto alvo (que pode ser uma variável ou sub-expressão) é especificado à esquerda do nome do método em vez de dentro da lista de parâmetros. Para detalhes, vide <a href="#object-protocol">Protocolo dos Objetos</a>.</p>

<h2 id="control-flow">Fluxo de Controle</h2>
<p><em>Fluxo de controle</em> é a ordem na qual instruções individuais são executadas. Normalmente as instruções são executadas sequencialmente de cima para baixo, mas uma instrução de controle de fluxo pode ignorar essa ordem (tomar precedência), tal como quando se especifica que as instruções devem ser executadas repetidamente, ou somente se determinada condição for atingida.</p>
<dl>
  <dt id="statement">Instrução</dt>
  <dd><p>Uma <em>instrução</em> é simplesmente o menor elemento da linguagem que expressa uma ação a ser executada. No AutoHotkey, instruções incluem comandos, atribuições de valor, chamadas de funções e outras expressões. Porém, diretivas, rótulos (incluindo hotkeys e hotstrings) e declarações sem atribuições de valor não são instruções; eles são processados assim que o programa inicia, antes de o script <em>executar</em>.</p></dd>
  <dt id="execute">Executar</dt>
  <dd><p>Fazer, executar, exercer, calcular, avaliar, pôr em efeito, etc. <em>Executar</em> tem basicamente o mesmo significado que tem fora do jargão da programação.</p></dd>
  <dt id="cf-body">Corpo</dt>
  <dd><p>O <em>corpo</em> de uma instrução de fluxo de controle é a instrução ou grupo de instruções às quais aquele se aplica. Por exemplo, o corpo de uma <a href="Language.htm#if-statement">instrução com if</a> é executado somente se uma condição específica é atingida.</p></dd>
</dl>
<p>Considere, como exemplo, este pequeno conjunto de instruções:</p>
<ol>
  <li>Abrir o Bloco de Notas</li>
  <li>Aguardar que o Bloco de Notas apareça na tela</li>
  <li>Digitar (enviar teclas) “Olá, mundo!”</li>
</ol>
<p>Damos um passo de cada vez, e quando esse passo é concluído, passamos para o próximo. Da mesma forma, o controle em um programa ou script normalmente segue de uma instrução para a próxima. Mas e se quisermos digitar sobre uma janela já existente do Bloco de Notas? Considere este conjunto revisado de instruções:</p>
<ol>
  <li>Se o Bloco de Notas não estiver em execução:
<ol>
  <li>Abrir o Bloco de Notas</li>
  <li>Aguardar que o Bloco de Notas apareça na tela</li>
</ol>
</li>
  <li>Do contrário:
<ol>
  <li>Ative a janela do Bloco de Notas</li>
</ol>
</li>
  <li>Digitar (enviar teclas) “Olá, mundo!”</li>
</ol>
<p>Então ou abrimos o Bloco de Notas ou ativamos sua janela dependendo de ele já estar ou não em execução. #1 é uma <em>instrução condicional</em>, também conhecida como uma <em>instrução com if</em>; isto é, nós executamos seu <em>corpo</em> (#1.1 - #1.2) somente se uma condição específica é atingida. #2 é uma <em>instrução com else</em>; nós executamos seu corpo (#2.1) somente se a condição de uma <em>instrução com if</em> anterior não tiver sido atingida. Dependendo da condição, o controle <em>flui</em> de uma dessas duas maneiras: #1 (se verdadeiro) → #1.1 → #1.2 → #3; ou #1 (se falso) → #2 (senão) → #2.1 → #3.</p>
<p>As instruções acima podem ser traduzidas no código abaixo:</p>
<pre>if (not WinExist("ahk_class Notepad"))
{
    Run Notepad
    WinWait ahk_class Notepad
}
else
    WinActivate ahk_class Notepad
Send Olá`, mundo!
</pre>
<p>Em nossas instruções escritas, nós usamos indentação e numeração para agrupar as instruções. Scripts funcionam de um jeito um pouco diferente. Conquanto a indentação deixa o código mais fácil de ler, no AutoHotkey ela não afeta o agrupamento de instruções. Em vez de indentação, as instruções são agrupadas envolvendo-se-as em chaves, como mostrado acima. Isso é chamado de <a href="commands/Block.htm"><em>bloco</em></a>.</p>
<p class="note">Para detalhes sobre a sintaxe - isto é, como escrever ou reconhecer instruções de fluxo de controle no AutoHotkey - veja <a href="Language.htm#control-flow">Fluxo de Controle</a>.</p>

<h2 id="details">Detalhes</h2>

<h3 id="string-encoding">Codificação de Strings</h3>
<p>Cada caractere na string é representado por um número, chamado de <em>número ordinal do caractere</em>, ou <em>código do caractere</em>. Por exemplo, o valor “Abc” seria representado assim:</p>
<table class="info" style="width: 8em; text-align: center">
  <tr><td>A</td><td>b</td><td>c</td></tr>
  <tr><td>65</td><td>98</td><td>99</td><td>0</td></tr>
</table>
<p><strong>Codificação:</strong> a <em>codificação</em> de uma string define como os símbolos são mapeados para números ordinais, e números ordinais para bytes. Há várias diferentes codificações, mas todas as que são suportadas pelo AutoHotkey incluem a ASCII como um subconjunto; caracteres de códigos 0 a 127 sempre têm o mesmo significado. Por exemplo, “A” sempre terá o código de caractere 65.</p>
<p id="null-termination"><strong>Terminação nula:</strong> cada string é finalizada com um “caractere nulo”, ou, em outras palavras, um caractere com valor binário zero marca o fim da string. O comprimento de uma string não precisa ser armazenado uma vez que ele pode ser inferido pela posição do caractere finalizador. Com vistas no desempenho, o AutoHotkey às vezes armazena o comprimento, como na ocasião em que uma string é armazenada numa variável.</p>
<p class="warning"><strong>Observação:</strong> devido à dependência na terminação no caractere nulo, o AutoHotkey v1 em geral não suporta strings com caracteres nulos incorporados. Tais strings podem ser criadas com <a href="commands/VarSetCapacity.htm">VarSetCapacity()</a> e <a href="commands/NumPut.htm">NumPut()</a> ou <a href="commands/DllCall.htm">DllCall()</a>, mas podem gerar efeitos inconsistentes.</p>
<p id="native-encoding"><strong>Codificação nativa:</strong> apesar de o AutoHotkey proporcionar meios de trabalhar com texto em várias codificações, os comandos e funções nativos — e até certo ponto a linguagem em si — assumem, todos eles, que os valores de strings estão em uma codificação em particular. Isso é chamado aqui de codificação <em>nativa</em>. A codificação nativa depende da versão do AutoHotkey.</p>
<ul>
  <li>
<p>As versões Unicode do AutoHotkey usam UTF-16. O menor elemento em uma string em UTF-16 possui dois bytes (16 bits). Caracteres Unicode no intervalo 0 a 65535 (U+FFFF) são representados por uma única unidade de código 16 bits do mesmo valor, enquanto os caracteres no intervalo 65536 (U+10000) a 1114111 (U+10FFFF) são representados por um <em>par substituto</em>; isto é, exatamente duas unidades de código 16-bits entre 0xD800 e 0xDFFF. (Para explicações mais detalhadas dos pares substitutos e seus métodos de codificação e decodificação, pesquise na Internet.)</p>
</li>
  <li>
<p>Versões ANSI do AutoHotkey usam a página de código padrão ANSI, que depende da região do sistema ou a configuração “idioma para programas não Unicode” do sistema. O menor elemento de uma string ANSI é um byte. Entretanto, algumas páginas de código contêm caracteres que são representados por sequências de múltiplos bytes (estas são sempre caracteres não ASCII).</p>
</li>
</ul>
<p id="character"><strong>Caractere:</strong> geralmente, outras partes desta documentação usam o termo “caractere” para se referir à menor unidade de uma string; usa-se aqui também “bytes” para strings ANSI e “unidades de código 16 bits” para strings Unicode (UTF-16). Por razões de praticidade, o comprimento de uma string e posições no interior de uma string são medidas contando-se essas unidades de tamanho fixo, mesmo que elas possam não ser caracteres Unicode completos.</p>
<p>Os comandos <a href="commands/FileRead.htm">FileRead</a>, <a href="commands/FileAppend.htm">FileAppend</a>, a função <a href="commands/FileOpen.htm">FileOpen()</a> e o <a href="objects/File.htm">Objeto arquivo</a> fornecem meios de ler e escrever texto com uma codificação específica em arquivos.</p>
<p>As funções <a href="commands/StrGet.htm">StrGet</a> e <a href="commands/StrPut.htm">StrPut</a> podem ser usadas para converter strings entre a codificação nativa e alguma outra codificação especificada. Entretanto, essas funções só são úteis em combinação com estruturas de dados e com a função <a href="commands/DllCall.htm">DllCall</a>. Strings que são passadas diretamente de ou para <a href="commands/DllCall.htm">DllCall()</a> podem ser convertidas para ANSI ou UTF-16 usando-se os tipos de parâmetros <code>AStr</code> ou <code>WStr</code>.</p>
<p>Técnicas para lidar com as diferenças entre as versões ANSI e Unicode do AutoHotkey podem ser encontradas na página <a href="Compat.htm#Format">Unicode x ANSI</a>.</p>

<h3 id="pure-numbers">Números Puros</h3>
<p>Um número <em>puro</em> ou <em>binário</em> é aquele que é armazenado na método em um formato com que o processador do computador pode trabalhar diretamente, como para realizar operações matemáticas. Na maioria dos casos, AutoHotkey converte automaticamente entre strings numéricas e números puros conforme necessário, e raramente diferencia entre os dois tipos. O AutoHotkey primariamente usa dois tipos de dados para números puros:</p>
<ul>
  <li>Inteiros 64 bits (signed, <em>int64</em>).</li>
  <li>Números de ponto flutuante 64 bits binários (o formato <em>double</em> ou <em>binary64</em> do padrão internacional 754 do IEEE.</li>
</ul>
<p>Em outras palavras, scripts são afetados pelas limitações seguintes:</p>
<ul>
  <li>
<p>Inteiros devem estar no intervalo 9223372036854775808 (-0x8000000000000000, ou -2<sup>63</sup>) a 9223372036854775807 (0x7FFFFFFFFFFFFFFF, ou 2<sup>63</sup>-1). Apesar de valores maiores poderem ser contidos numa string, qualquer tentativa de converter a string em um número (como pelo uso da string numa operação matemática) pode gerar resultados inconsistentes.</p>
</li>
  <li>
<p>Números de ponto flutuante geralmente suportam 15 dígitos de precisão. Porém, converter um número de ponto flutuante em uma string faz com que o número seja arredondado de acordo com o <a href="commands/SetFormat.htm#Float">formato de ponto flutuante</a> atual, que, por padrão, tem 6 casas decimais. Se o modo “lento” do comando <a href="commands/SetFormat.htm">SetFormat</a> está presente em qualquer lugar do script, números são <em>sempre</em> convertidos em strings quando atribuídos a uma <a href="#variables">variável</a>.</p>
</li>
</ul>
<p><strong>Observação:</strong> há algumas frações decimais cujo formato de ponto flutuante não pode representar precisamente, então um número é arredondado para o número representável mais próximo. Isso pode levar a resultados inesperados. Por exemplo:</p>
<pre>SetFormat FloatFast, 0.17  <em>; Mostrar precisão "além do máximo"</em>
MsgBox % 0.1 + 0           <em>; 0.10000000000000001</em>
MsgBox % 0.1 + 0.2         <em>; 0.30000000000000004</em>
MsgBox % 0.3 + 0           <em>; 0.29999999999999999</em>
MsgBox % 0.1 + 0.2 = 0.3   <em>; 0 (not equal)</em>
</pre>
<p>Uma estratégia para lidar com isso é evitar a comparação direta, e fazer a comparação da diferença no lugar. Por exemplo:</p>
<pre>MsgBox % Abs((0.1 + 0.2) - (0.3)) &lt; 0.0000000000000001
</pre>
<p>Outra estratégia é sempre converter para string (logo, aplicando o arredondamento) antes da comparação. Há geralmente dois modos de fazer isso enquanto se especifica a precisão, e ambos são mostrados abaixo:</p>
<pre>MsgBox % Round(0.1 + 0.2, 15) = Format("{:.15f}", 0.3)
</pre>

<h3 id="names">Nomes</h3>
<p>AutoHotkey usa o mesmo conjunto de regras para denominar várias coisas, inclusive variáveis, funções, <a href="commands/GroupAdd.htm">grupos de janelas</a>, <a href="commands/Gui.htm">GUIs</a>, classes e métodos:</p>
<ul>
  <li><strong>Diferenciação entre maiúsculas e minúsculas:</strong> nenhuma para caracteres ASCII. Por exemplo, <code>CurrentDate</code> é o mesmo que <code>currentdate</code>. Todavia, caracteres não ASCII maiúsculos, como “Ä”, <em>não são</em> consideradas iguais aos seus correspondentes minúsculos, independentemente da configuração de região do usuário. Isso ajuda o script a se comportar de maneira consistente entre múltiplas configurações regionais.</li>
  <li><strong>Comprimento máximo:</strong> 253 caracteres.</li>
  <li><strong>Caracteres permitidos:</strong> letras, números, caracteres não ASCII e os símbolos seguintes: _ # @ $</li>
</ul>
<p>Devido a convenções de estilo, é geralmente melhor nomear suas variáveis usando somente letras, números e o caractere _ (por exemplo:) <em>PosicaoCursor</em>, <em>Total_itens</em> e <em>entrada_eh_valida</em>). Esse estilo permite que pessoas familiarizadas com outras linguagens entendam seus scripts mais facilmente.</p>
<p>Embora uma <a href="#variables">variável</a> possa consistir totalmente de algarismos, fazer isso geralmente só é usado para <a href="Scripts.htm#cmd_args_old">parâmetros de entrada da linha de comando</a>. Esses nomes numéricos não podem ser usados em expressões porque eles seriam vistos como números e não como variáveis. É melhor evitar iniciar um nome de variável com um algarismo, já que esses nomes levam a confusões e serão considerados inválidos no AutoHotkey v2.</p>
<p>E, dado que os caracteres a seguir poderão estar reservados para outros fins na versão 2 do AutoHotkey, recomenda-se evitá-los: # @ $</p>
<p>Nomes de propriedades em classes têm as mesmas regras e restrições dos nomes de variáveis, exceto que os três caracteres listados acima (# @ $) não são permitidos. Apesar de poderem ser usados na definição de um método, chamar um método desse exigirá o uso de colchetes. Por exemplo, <code>meuObjeto.@home()</code> não é válido, mas <code>meuObjeto["@home"]()</code> é aceitável.</p>

<h3 id="variable-references">Referências a Variáveis x Valores</h3>
<p>Variáveis têm certos atributos que turvam a linha que diferencia uma variável de seu valor, mas é importante fazer a distinção. Em particular, considere <a href="#objects">objetos</a> e parâmetros ByRef.</p>
<p>Não obstante possamos dizer que a variável <code>meuVetor</code> <em>contém</em> um vetor (o que é um tipo de objeto), o que a variável contém não é o vetor em si mas uma <em>referência ou ponteiro</em> para o vetor. Qualquer número de variáveis pode conter uma referência para o mesmo objeto. Pode ser útil pensar numa variável como simplesmente um nome, nesse caso. Exemplificativamente, dar a uma pessoa um apelido não faz com que surja um clone daquela pessoa.</p>
<p>Por padrão, variáveis são passadas para funções definidas pelo usuário <em>por valor</em>. Ou seja, o valor contido na variável é copiado para a variável que corresponde ao parâmetro da função. Parâmetros <strong>ByRef</strong> permitem que você passe uma variável <em>por referência</em>, ou, em outras palavras, tornar um parâmetro da função um <em>codinome</em> para sua variável, permitindo que a função atribua um novo valor para sua variável.</p>
<p>Como uma variável somente contém, a qualquer momento, uma <em>referência</em> para um objeto e não o objeto em si, quando você passar uma variável dessa para um parâmetro que não seja ByRef, o que a função recebe é uma referência ao mesmo objeto. Isso permite que a função modifique o objeto, mas não permite que a função modifique a <em>variável</em> que o chamador da função empregou, pois a função apenas tem uma referência ao objeto, não à variável.</p>

<h3 id="references-to-objects">Referências a Objetos</h3>
<p>Scripts interagem com um objeto só indiretamente, através de uma <em>referência</em> ao objeto. Quando você cria um objeto, o objeto é criado em certo local que você não controla, e a você é dada uma referência. Passar essa referência a uma função ou armazená-la numa variável ou outro objeto cria uma nova referência ao <em>mesmo</em> objeto. Você libera uma referência ao simplesmente usar uma atribuição para substituí-la por qualquer outro valor. Um objeto só é excluído depois que todas as referências a ele são liberadas; você não pode excluir um objeto explicitamente, e não deve tentar fazê-lo.</p>
<pre>ref1 := Object()  <em>; Criar um objeto e armazenar sua primeira referência</em>
ref2 := ref1      <em>; Criar uma nova referência para o mesmo objeto</em>
ref1 := ""        <em>; Libera a primeira referência</em>
ref2 := ""        <em>; Libera a segunda referência; o objeto é excluído</em>
</pre>
<p>Se está difícil entender, tente pensar nos objetos como uma casa que você aluga. Quando você aluga uma unidade residencial, você recebe uma chave que você pode usar para acessá-la. Você pode obter mais chaves e usá-las para acessar a mesma casa, mas quando você tiver terminado seu período locatício, você deverá devolver todas as chaves ao responsável pela locação. Geralmente uma unidade residencial não seria <em>deletada</em>, mas talvez o representante da imobiliária providenciará a remoção de toda tralha que você tiver deixado para trás; da mesma forma que quaisquer valores armazenados num objeto são liberados quando o objeto é excluído.</p>

</body>
</html>
